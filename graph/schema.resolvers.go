package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"backend/cookie"
	"backend/graph/model"
	"backend/graph/utils"
	"context"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/google/uuid"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}
func getStringOrDefault(value *string, defaultValue string) string {
	if value == nil {
		return defaultValue
	}
	return *value
}

// Timestamp is the resolver for the timestamp field.
func (r *historyResolver) Timestamp(ctx context.Context, obj *model.History) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	// Check if the email already exists
	existingUser := &model.User{}
	err := collection.FindOne(ctx, bson.M{"email": input.Email}).Decode(existingUser)
	if err == nil {
		return nil, fmt.Errorf("email already exists")
	} else if err != mongo.ErrNoDocuments {
		return nil, fmt.Errorf("error checking email: %v", err)
	}

	// Hash password
	hashedPassword, err := HashPassword(*input.Password)
	if err != nil {
		return nil, fmt.Errorf("error hashing password: %v", err)
	}

	user := &model.User{
		UserID:    uuid.New().String(),
		UserImage: getStringOrDefault(input.UserImage, ""),
		FirstName: *input.FirstName,
		LastName:  *input.LastName,
		Email:     *input.Email,
		Phone:     getStringOrDefault(input.Phone, ""),
		Password:  hashedPassword,
		City:      getStringOrDefault(input.City, ""),
		Country:   getStringOrDefault(input.Country, ""),
	}

	_, err = collection.InsertOne(ctx, user)
	if err != nil {
		return nil, fmt.Errorf("error creating user: %v", err)
	}

	// Create a history record
	historyCollection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))
	err = utils.CreateHistoryRecord(ctx, historyCollection, user.UserID, "User", "Create", fmt.Sprintf(`Created Account with email: "%s"`, user.Email))
	if err != nil {
		return nil, fmt.Errorf("error creating history: %v", err)
	}

	notificationCollection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))
	message := "We are delighted to have you as a part of our community, " + user.FirstName + ". Your new account opens the door to a wealth of opportunities and resources in the oil and gas industry. At Aramco, we pride ourselves on innovation, excellence, and a commitment to sustainable energy solutions."
	err = utils.CreateNotification(ctx, notificationCollection, user.UserID, message)
	if err != nil {
		return nil, fmt.Errorf("error creating notification: %v", err)
	}

	generateVerificationCode := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION"))
	err = utils.CreateVerificationCode(ctx, generateVerificationCode, user.Email)
	if err != nil {
		return nil, fmt.Errorf("error passing email: %v", err)
	}

	return user, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	var user model.User
	err := collection.FindOne(ctx, bson.M{"email": email}).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return "", fmt.Errorf("invalid email or password")
		}
		return "", err
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return "", fmt.Errorf("invalid email or password")
	}

	token, err := utils.GenerateJWT(user.UserID)
	if err != nil {
		return "", fmt.Errorf("could not generate token: %v", err)
	}

	// Set the token as a cookie
	w := cookie.GetResponseWriter(ctx)
	http.SetCookie(w, &http.Cookie{
		Name:     "token",
		Value:    token,
		Path:     "/",
		Expires:  time.Now().Add(24 * time.Hour),
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	})

	return token, nil
}

// EditUser is the resolver for the editUser field.
func (r *mutationResolver) EditUser(ctx context.Context, userID string, input model.CreateUserInput) (*model.User, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	// Function to find the user by userID
	var existingUser model.User
	err := collection.FindOne(ctx, bson.M{"userid": userID}).Decode(&existingUser)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("no user found with userID: %s", userID)
		}
		return nil, fmt.Errorf("error finding user: %v", err)
	}

	// Update fields if they are provided
	update := bson.M{}
	if input.FirstName != nil {
		update["firstname"] = *input.FirstName
	}
	if input.LastName != nil {
		update["lastname"] = *input.LastName
	}
	if input.Email != nil {

		update["email"] = *input.Email
	}
	if input.Phone != nil {
		update["phone"] = *input.Phone
	}
	if input.City != nil {
		update["city"] = *input.City
	}
	if input.Country != nil {
		update["country"] = *input.Country
	}
	if input.UserImage != nil {
		update["userimage"] = *input.UserImage
	}
	if input.Password != nil {
		// Hash the new password
		hashedPassword, err := HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("error hashing password: %v", err)
		}
		update["password"] = hashedPassword
	}

	// Update the user in the database
	_, err = collection.UpdateOne(ctx, bson.M{"userid": userID}, bson.M{"$set": update})
	if err != nil {
		return nil, fmt.Errorf("error updating user: %v", err)
	}

	// Fetch the updated user
	err = collection.FindOne(ctx, bson.M{"userid": userID}).Decode(&existingUser)
	if err != nil {
		return nil, fmt.Errorf("error fetching updated user: %v", err)
	}

	return &existingUser, nil
}

// DeleteAllUsers is the resolver for the deleteAllUsers field.
func (r *mutationResolver) DeleteAllUsers(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllUsers - deleteAllUsers"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// DeleteAllHistory is the resolver for the deleteAllHistory field.
func (r *mutationResolver) DeleteAllHistory(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllHistory - deleteAllHistory"))
}

// DeleteHistory is the resolver for the deleteHistory field.
func (r *mutationResolver) DeleteHistory(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteHistory - deleteHistory"))
}

// DeleteAllTransactions is the resolver for the deleteAllTransactions field.
func (r *mutationResolver) DeleteAllTransactions(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllTransactions - deleteAllTransactions"))
}

// DeleteTransaction is the resolver for the deleteTransaction field.
func (r *mutationResolver) DeleteTransaction(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTransaction - deleteTransaction"))
}

// CreateNotification is the resolver for the createNotification field.
func (r *mutationResolver) CreateNotification(ctx context.Context, userID string, message string) (*model.Notification, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))

	notification := &model.Notification{
		ID:        uuid.New().String(),
		UserID:    userID,
		Message:   message,
		Seen:      false,
		Timestamp: time.Now(),
	}

	_, err := collection.InsertOne(ctx, notification)
	if err != nil {
		return nil, fmt.Errorf("error creating notification: %v", err)
	}

	return notification, nil
}

// MarkNotificationAsSeen is the resolver for the markNotificationAsSeen field.
func (r *mutationResolver) MarkNotificationAsSeen(ctx context.Context, id string) (*model.Notification, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))

	filter := bson.M{"id": id}
	update := bson.M{"$set": bson.M{"seen": true}}

	var notification model.Notification
	err := collection.FindOneAndUpdate(ctx, filter, update).Decode(&notification)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no notification found with id: %s", id)
	} else if err != nil {
		return nil, fmt.Errorf("error updating notification: %v", err)
	}

	return &notification, nil
}

// DeleteAllUnverifiedEmails is the resolver for the deleteAllUnverifiedEmails field.
func (r *mutationResolver) DeleteAllUnverifiedEmails(ctx context.Context) ([]*model.Verify, error) {
	panic(fmt.Errorf("not implemented: DeleteAllUnverifiedEmails - deleteAllUnverifiedEmails"))
}

// DeleteUnverifiedEmail is the resolver for the deleteUnverifiedEmail field.
func (r *mutationResolver) DeleteUnverifiedEmail(ctx context.Context, email string) (*model.Verify, error) {
	panic(fmt.Errorf("not implemented: DeleteUnverifiedEmail - deleteUnverifiedEmail"))
}

// Timestamp is the resolver for the timestamp field.
func (r *notificationResolver) Timestamp(ctx context.Context, obj *model.Notification) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// GetAllUsers is the resolver for the getAllUsers field.
func (r *queryResolver) GetAllUsers(ctx context.Context) ([]*model.User, error) {
	// Fetch all users from the database
	users, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching users: %v", err)
	}
	defer users.Close(ctx)

	// Iterate through the cursor and populate the results
	var result []*model.User
	for users.Next(ctx) {
		var user *model.User
		if err := users.Decode(&user); err != nil {
			return nil, fmt.Errorf("error decoding user: %v", err)
		}
		result = append(result, user)
	}

	if err := users.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*model.User, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	var user model.User
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no user found with userID: %s", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding user: %v", err)
	}

	return &user, nil
}

// GetAllAssets is the resolver for the getAllAssets field.
func (r *queryResolver) GetAllAssets(ctx context.Context) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: GetAllAssets - getAllAssets"))
}

// GetAsset is the resolver for the getAsset field.
func (r *queryResolver) GetAsset(ctx context.Context, assetID string) (*model.Asset, error) {
	panic(fmt.Errorf("not implemented: GetAsset - getAsset"))
}

// GetUserAssets is the resolver for the getUserAssets field.
func (r *queryResolver) GetUserAssets(ctx context.Context, userID string) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: GetUserAssets - getUserAssets"))
}

// GetAllHistory is the resolver for the getAllHistory field.
func (r *queryResolver) GetAllHistory(ctx context.Context) ([]*model.History, error) {
	histories, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching history: %v", err)
	}
	defer histories.Close(ctx)

	var result []*model.History
	for histories.Next(ctx) {
		var history *model.History
		if err := histories.Decode(&history); err != nil {
			return nil, fmt.Errorf("error decoding history: %v", err)
		}
		result = append(result, history)
	}

	return result, nil
}

// GetHistory is the resolver for the getHistory field.
func (r *queryResolver) GetHistory(ctx context.Context, id string) (*model.History, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))

	var history model.History
	filter := bson.M{"id": id}

	err := collection.FindOne(ctx, filter).Decode(&history)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no history found with id: %s", id)
	} else if err != nil {
		return nil, fmt.Errorf("error finding history: %v", err)
	}

	return &history, nil
}

// GetUserHistory is the resolver for the getUserHistory field.
func (r *queryResolver) GetUserHistory(ctx context.Context, userID string) ([]*model.History, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))

	filter := bson.M{"userid": userID}

	// Query MongoDB for history records matching the filter
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching history: %v", err)
	}
	defer cursor.Close(ctx)

	// Initialize slice to store fetched history records
	var histories []*model.History

	// Iterate through the cursor and decode each document into a History struct
	for cursor.Next(ctx) {
		var history model.History
		if err := cursor.Decode(&history); err != nil {
			return nil, fmt.Errorf("error decoding history: %v", err)
		}
		histories = append(histories, &history)
	}

	// Check for any cursor errors after iteration
	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return histories, nil
}

// GetAllTransactions is the resolver for the getAllTransactions field.
func (r *queryResolver) GetAllTransactions(ctx context.Context) ([]*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: GetAllTransactions - getAllTransactions"))
}

// GetTransaction is the resolver for the getTransaction field.
func (r *queryResolver) GetTransaction(ctx context.Context, id string) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: GetTransaction - getTransaction"))
}

// GetUserTransactions is the resolver for the getUserTransactions field.
func (r *queryResolver) GetUserTransactions(ctx context.Context, userID string) ([]*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: GetUserTransactions - getUserTransactions"))
}

// GetAllNotification is the resolver for the getAllNotification field.
func (r *queryResolver) GetAllNotification(ctx context.Context) ([]*model.Notification, error) {
	panic(fmt.Errorf("not implemented: GetAllNotification - getAllNotification"))
}

// GetUserNotifications is the resolver for the getUserNotifications field.
func (r *queryResolver) GetUserNotifications(ctx context.Context, userID string) ([]*model.Notification, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))

	filter := bson.M{"userid": userID}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching notifications: %v", err)
	}
	defer cursor.Close(ctx)

	var notifications []*model.Notification
	for cursor.Next(ctx) {
		var notification model.Notification
		if err := cursor.Decode(&notification); err != nil {
			return nil, fmt.Errorf("error decoding notification: %v", err)
		}
		notifications = append(notifications, &notification)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return notifications, nil
}

// GetAllUnverifiedEmails is the resolver for the getAllUnverifiedEmails field.
func (r *queryResolver) GetAllUnverifiedEmails(ctx context.Context) ([]*model.Verify, error) {
	allUnverified, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching unverified emails: %v", err)
	}
	defer allUnverified.Close(ctx)

	var result []*model.Verify
	for allUnverified.Next(ctx) {
		var unverified *model.Verify
		if err := allUnverified.Decode(&unverified); err != nil {
			return nil, fmt.Errorf("error decoding unverified email: %v", err)
		}
		result = append(result, unverified)
	}
	if err := allUnverified.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetUnverifiedEmail is the resolver for the getUnverifiedEmail field.
func (r *queryResolver) GetUnverifiedEmail(ctx context.Context, email string) (*model.Verify, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION"))

	var user model.Verify
	filter := bson.M{"email": email}
	err := collection.FindOne(ctx, filter).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("%v not found. could be that the email address is already verified or does not exist", email)
	} else if err != nil {
		return nil, fmt.Errorf("error finding email: %v", err)
	}

	return &user, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Balance is the resolver for the balance field.
func (r *userResolver) Balance(ctx context.Context, obj *model.User) ([]*model.Balance, error) {
	panic(fmt.Errorf("not implemented: Balance - balance"))
}

// Investment is the resolver for the investment field.
func (r *userResolver) Investment(ctx context.Context, obj *model.User) ([]*model.Investment, error) {
	panic(fmt.Errorf("not implemented: Investment - investment"))
}

// Credits is the resolver for the credits field.
func (r *userResolver) Credits(ctx context.Context, obj *model.User) ([]*model.Credit, error) {
	panic(fmt.Errorf("not implemented: Credits - credits"))
}

// Reference is the resolver for the reference field.
func (r *userResolver) Reference(ctx context.Context, obj *model.User) ([]*model.Reference, error) {
	panic(fmt.Errorf("not implemented: Reference - reference"))
}

// Assets is the resolver for the assets field.
func (r *userResolver) Assets(ctx context.Context, obj *model.User) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: Assets - assets"))
}

// History is the resolver for the history field.
func (r *userResolver) History(ctx context.Context, obj *model.User) ([]*model.History, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))

	cursor, err := collection.Find(ctx, bson.M{"user_id": obj.UserID})
	if err != nil {
		return nil, fmt.Errorf("error fetching history: %v", err)
	}
	defer cursor.Close(ctx)

	var histories []*model.History
	for cursor.Next(ctx) {
		var history model.History
		if err := cursor.Decode(&history); err != nil {
			return nil, fmt.Errorf("error decoding history: %v", err)
		}
		histories = append(histories, &history)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return histories, nil
}

// Transactions is the resolver for the transactions field.
func (r *userResolver) Transactions(ctx context.Context, obj *model.User) ([]*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: Transactions - transactions"))
}

// Notification is the resolver for the Notification field.
func (r *userResolver) Notification(ctx context.Context, obj *model.User) ([]*model.Notification, error) {
	panic(fmt.Errorf("not implemented: Notification - Notification"))
}

// ID is the resolver for the id field.
func (r *verifyResolver) ID(ctx context.Context, obj *model.Verify) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// History returns HistoryResolver implementation.
func (r *Resolver) History() HistoryResolver { return &historyResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Notification returns NotificationResolver implementation.
func (r *Resolver) Notification() NotificationResolver { return &notificationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// Verify returns VerifyResolver implementation.
func (r *Resolver) Verify() VerifyResolver { return &verifyResolver{r} }

type historyResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type verifyResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
