package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"backend/cookie"
	"backend/graph/model"
	"backend/graph/utils"
	"context"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/google/uuid"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"golang.org/x/crypto/bcrypt"
)

func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}
func getStringOrDefault(value *string, defaultValue string) string {
	if value == nil {
		return defaultValue
	}
	return *value
}

// Timestamp is the resolver for the timestamp field.
func (r *balanceResolver) Timestamp(ctx context.Context, obj *model.Balance) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *creditResolver) Timestamp(ctx context.Context, obj *model.Credit) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *historyResolver) Timestamp(ctx context.Context, obj *model.History) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *investmentResolver) Timestamp(ctx context.Context, obj *model.Investment) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	// Check if the email already exists
	existingUser := &model.User{}
	err := collection.FindOne(ctx, bson.M{"email": input.Email}).Decode(existingUser)
	if err == nil {
		return nil, fmt.Errorf("email already exists")
	} else if err != mongo.ErrNoDocuments {
		return nil, fmt.Errorf("error checking email: %v", err)
	}

	// Hash password
	hashedPassword, err := HashPassword(*input.Password)
	if err != nil {
		return nil, fmt.Errorf("error hashing password: %v", err)
	}

	user := &model.User{
		UserID:    uuid.New().String(),
		UserImage: getStringOrDefault(input.UserImage, ""),
		FirstName: *input.FirstName,
		LastName:  *input.LastName,
		Email:     *input.Email,
		Phone:     getStringOrDefault(input.Phone, ""),
		Password:  hashedPassword,
		City:      getStringOrDefault(input.City, ""),
		Country:   getStringOrDefault(input.Country, ""),
		Type:      "USER",
	}

	_, err = collection.InsertOne(ctx, user)
	if err != nil {
		return nil, fmt.Errorf("error creating user: %v", err)
	}

	//Create Memo
	userMemo := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("MEMO"))
	err = utils.CreateMemo(ctx, userMemo, user.UserID)
	if err != nil {
		return nil, fmt.Errorf("error generating memo: %v", err)
	}
	// Create a Balance record
	BalanceInit := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("BALANCES"))
	err = utils.CreateBalance(ctx, BalanceInit, user.UserID)
	if err != nil {
		return nil, fmt.Errorf("error creating balance: %v", err)
	}
	// Create an Investment record
	InvestmentInit := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("INVESTMENTS"))
	err = utils.CreateInvestment(ctx, InvestmentInit, user.UserID)
	if err != nil {
		return nil, fmt.Errorf("error creating investment: %v", err)
	}
	// Create a credit record
	CreditInit := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("CREDITS"))
	err = utils.CreateCredit(ctx, CreditInit, user.UserID)
	if err != nil {
		return nil, fmt.Errorf("error creating credit: %v", err)
	}
	// Create a reference record
	ReferenceInit := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERERS"))
	err = utils.CreateReference(ctx, ReferenceInit, user.UserID)
	if err != nil {
		return nil, fmt.Errorf("error creating balance: %v", err)
	}
	// Create a history record
	historyCollection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))
	err = utils.CreateHistoryRecord(ctx, historyCollection, user.UserID, "User", "Created", fmt.Sprintf(`Created Account with email: "%s"`, user.Email))
	if err != nil {
		return nil, fmt.Errorf("error creating history: %v", err)
	}

	notificationCollection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))
	message := "We are delighted to have you as a part of our community, " + user.FirstName + ". Your new account opens the door to a wealth of opportunities and resources in the oil and gas industry. At Aramco, we pride ourselves on innovation, excellence, and a commitment to sustainable energy solutions."
	err = utils.CreateNotification(ctx, notificationCollection, user.UserID, message)
	if err != nil {
		return nil, fmt.Errorf("error creating notification: %v", err)
	}

	generateVerificationCode := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION"))
	err = utils.CreateVerificationCode(ctx, generateVerificationCode, user.Email)
	if err != nil {
		return nil, fmt.Errorf("error passing email: %v", err)
	}

	generateReferralCode := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERRAL"))
	err = utils.CreateReferralCode(ctx, generateReferralCode, user.UserID)
	if err != nil {
		return nil, fmt.Errorf("error creating  personalized user referral code: %v", err)
	}

	return user, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	var user model.User
	err := collection.FindOne(ctx, bson.M{"email": email}).Decode(&user)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return "", fmt.Errorf("invalid email or password")
		}
		return "", err
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return "", fmt.Errorf("invalid email or password")
	}

	token, err := utils.GenerateJWT(user.UserID)
	if err != nil {
		return "", fmt.Errorf("could not generate token: %v", err)
	}

	// Set the token as a cookie
	w := cookie.GetResponseWriter(ctx)
	http.SetCookie(w, &http.Cookie{
		Name:     "token",
		Value:    token,
		Path:     "/",
		Expires:  time.Now().Add(24 * time.Hour),
		HttpOnly: true,
		SameSite: http.SameSiteStrictMode,
	})

	return token, nil
}

// EditUser is the resolver for the editUser field.
func (r *mutationResolver) EditUser(ctx context.Context, userID string, input model.CreateUserInput) (*model.User, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	// Function to find the user by userID
	var existingUser model.User
	err := collection.FindOne(ctx, bson.M{"userid": userID}).Decode(&existingUser)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("no user found with userID: %s", userID)
		}
		return nil, fmt.Errorf("error finding user: %v", err)
	}

	// Update fields if they are provided
	update := bson.M{}
	if input.FirstName != nil {
		update["firstname"] = *input.FirstName
	}
	if input.LastName != nil {
		update["lastname"] = *input.LastName
	}
	if input.Email != nil {

		update["email"] = *input.Email
	}
	if input.Phone != nil {
		update["phone"] = *input.Phone
	}
	if input.City != nil {
		update["city"] = *input.City
	}
	if input.Country != nil {
		update["country"] = *input.Country
	}
	if input.UserImage != nil {
		update["userimage"] = *input.UserImage
	}
	if input.Password != nil {
		// Hash the new password
		hashedPassword, err := HashPassword(*input.Password)
		if err != nil {
			return nil, fmt.Errorf("error hashing password: %v", err)
		}
		update["password"] = hashedPassword
	}

	// Update the user in the database
	_, err = collection.UpdateOne(ctx, bson.M{"userid": userID}, bson.M{"$set": update})
	if err != nil {
		return nil, fmt.Errorf("error updating user: %v", err)
	}

	// Fetch the updated user
	err = collection.FindOne(ctx, bson.M{"userid": userID}).Decode(&existingUser)
	if err != nil {
		return nil, fmt.Errorf("error fetching updated user: %v", err)
	}

	return &existingUser, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, email string, newPassword string) (*string, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	var existingUser model.User
	err := collection.FindOne(ctx, bson.M{"email": email}).Decode(&existingUser)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("no user found with email: %s", email)
		}
		return nil, fmt.Errorf("error finding user: %v", err)
	}

	hashedPassword, err := HashPassword(newPassword)
	if err != nil {
		return nil, fmt.Errorf("error hashing password: %v", err)
	}

	update := bson.M{
		"password": hashedPassword,
	}

	_, err = collection.UpdateOne(ctx, bson.M{"email": email}, bson.M{"$set": update})
	if err != nil {
		return nil, fmt.Errorf("error updating user: %v", err)
	}

	return &existingUser.Email, nil
}

// DeleteAllUsers is the resolver for the deleteAllUsers field.
func (r *mutationResolver) DeleteAllUsers(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllUsers - deleteAllUsers"))
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// DeleteBalance is the resolver for the deleteBalance field.
func (r *mutationResolver) DeleteBalance(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteBalance - deleteBalance"))
}

// DeleteInvestment is the resolver for the deleteInvestment field.
func (r *mutationResolver) DeleteInvestment(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteInvestment - deleteInvestment"))
}

// DeleteCredit is the resolver for the deleteCredit field.
func (r *mutationResolver) DeleteCredit(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteCredit - deleteCredit"))
}

// DeleteReference is the resolver for the deleteReference field.
func (r *mutationResolver) DeleteReference(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteReference - deleteReference"))
}

// DeleteAllMemos is the resolver for the deleteAllMemos field.
func (r *mutationResolver) DeleteAllMemos(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllMemos - deleteAllMemos"))
}

// DeleteMemo is the resolver for the deleteMemo field.
func (r *mutationResolver) DeleteMemo(ctx context.Context, userID string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteMemo - deleteMemo"))
}

// DeleteAllHistory is the resolver for the deleteAllHistory field.
func (r *mutationResolver) DeleteAllHistory(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllHistory - deleteAllHistory"))
}

// DeleteHistory is the resolver for the deleteHistory field.
func (r *mutationResolver) DeleteHistory(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteHistory - deleteHistory"))
}

// MakeTransaction is the resolver for the makeTransaction field.
func (r *mutationResolver) MakeTransaction(ctx context.Context, input model.MakeTransfer) (*model.Transaction, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("TRANSACT"))

	transaction := &model.Transaction{
		From:   *input.From,
		To:     *input.To,
		Amount: *input.Amount,
	}

	// Declare err with :=
	result, err := collection.InsertOne(ctx, transaction)
	fmt.Println("Inserted ID:", result.InsertedID)
	if err != nil {
		return nil, fmt.Errorf("error making transaction: %v", err)
	}

	return transaction, nil
}

// DeleteAllTransactions is the resolver for the deleteAllTransactions field.
func (r *mutationResolver) DeleteAllTransactions(ctx context.Context) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteAllTransactions - deleteAllTransactions"))
}

// DeleteTransaction is the resolver for the deleteTransaction field.
func (r *mutationResolver) DeleteTransaction(ctx context.Context, id string) (*bool, error) {
	panic(fmt.Errorf("not implemented: DeleteTransaction - deleteTransaction"))
}

// CreateNotification is the resolver for the createNotification field.
func (r *mutationResolver) CreateNotification(ctx context.Context, userID string, message string) (*model.Notification, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))

	notification := &model.Notification{
		ID:        uuid.New().String(),
		UserID:    userID,
		Message:   message,
		Seen:      false,
		Timestamp: time.Now(),
	}

	_, err := collection.InsertOne(ctx, notification)
	if err != nil {
		return nil, fmt.Errorf("error creating notification: %v", err)
	}

	return notification, nil
}

// MarkNotificationAsSeen is the resolver for the markNotificationAsSeen field.
func (r *mutationResolver) MarkNotificationAsSeen(ctx context.Context, id string) (*model.Notification, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))

	filter := bson.M{"id": id}
	update := bson.M{"$set": bson.M{"seen": true}}

	var notification model.Notification
	err := collection.FindOneAndUpdate(ctx, filter, update).Decode(&notification)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no notification found with id: %s", id)
	} else if err != nil {
		return nil, fmt.Errorf("error updating notification: %v", err)
	}

	return &notification, nil
}

// DeleteAllUnverifiedEmails is the resolver for the deleteAllUnverifiedEmails field.
func (r *mutationResolver) DeleteAllUnverifiedEmails(ctx context.Context) ([]*model.Verify, error) {
	panic(fmt.Errorf("not implemented: DeleteAllUnverifiedEmails - deleteAllUnverifiedEmails"))
}

// DeleteUnverifiedEmail is the resolver for the deleteUnverifiedEmail field.
func (r *mutationResolver) DeleteUnverifiedEmail(ctx context.Context, email string) (*model.Verify, error) {
	panic(fmt.Errorf("not implemented: DeleteUnverifiedEmail - deleteUnverifiedEmail"))
}

// CreatePlan is the resolver for the createPlan field.
func (r *mutationResolver) CreatePlan(ctx context.Context, input model.CreatePlanInput) (*model.Plan, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("PLANS"))

	newPlan := &model.Plan{
		ID:           uuid.New().String(),
		Title:        input.Title,
		Amount:       input.Amount,
		Return:       input.Return,
		Duration:     input.Duration,
		ReferalBonus: input.ReferalBonus,
		Description:  []model.Description{},
	}

	for _, descInput := range input.Description {
		newDescription := model.Description{
			ID:    uuid.New().String(),
			Point: descInput.Point,
		}
		newPlan.Description = append(newPlan.Description, newDescription)
	}

	_, err := collection.InsertOne(ctx, newPlan)
	if err != nil {
		return nil, fmt.Errorf("error creating plan: %v", err)
	}

	return newPlan, nil
}

// UpdatePlan is the resolver for the updatePlan field.
func (r *mutationResolver) UpdatePlan(ctx context.Context, planID string, input model.UpdatePlanInput) (*model.Plan, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("PLANS"))

	var existingPlan model.Plan
	err := collection.FindOne(ctx, bson.M{"id": planID}).Decode(&existingPlan)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("no plan found with id: %s", planID)
		}
		return nil, fmt.Errorf("error finding plan by id: %s", planID)
	}

	update := bson.M{}
	if input.Title != nil {
		update["title"] = *input.Title
	}
	if input.Amount != nil {
		update["amount"] = *input.Amount
	}
	if input.Return != nil {
		update["return"] = *input.Return
	}
	if input.Duration != nil {
		update["duration"] = *input.Duration
	}
	if input.ReferalBonus != nil {
		update["referalBonus"] = *input.ReferalBonus
	}

	if input.Description != nil {
		var descriptions []model.Description
		for _, descInput := range input.Description {
			newDescription := model.Description{
				ID:    uuid.New().String(),
				Point: descInput.Point,
			}
			descriptions = append(descriptions, newDescription)
		}
		update["description"] = descriptions
	}

	_, err = collection.UpdateOne(ctx, bson.M{"id": planID}, bson.M{"$set": update})
	if err != nil {
		return nil, fmt.Errorf("error updating plan: %v", err)
	}

	err = collection.FindOne(ctx, bson.M{"id": planID}).Decode(&existingPlan)
	if err != nil {
		return nil, fmt.Errorf("error finding updated plan by id: %v", err)
	}

	return &existingPlan, nil
}

// DeletePlan is the resolver for the deletePlan field.
func (r *mutationResolver) DeletePlan(ctx context.Context, planID string) (*bool, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("PLANS"))

	// Attempt to delete the plan with the given ID
	deleteResult, err := collection.DeleteOne(ctx, bson.M{"id": planID})
	if err != nil {
		return nil, fmt.Errorf("error deleting plan: %v", err)
	}

	// Check if a plan was deleted
	if deleteResult.DeletedCount == 0 {
		return nil, fmt.Errorf("no plan found with the ID: %s", planID)
	}

	// Return success
	success := true
	return &success, nil
}

// EditWallet is the resolver for the editWallet field.
func (r *mutationResolver) EditWallet(ctx context.Context, walletID string, input model.EditWalletInput) (*model.Wallet, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("WALLET"))

	var existingWallet model.Wallet
	err := collection.FindOne(ctx, bson.M{"walletID": walletID}).Decode(&existingWallet)
	if err != nil {
		return nil, fmt.Errorf("wallet not found %v", err)
	}

	if input.Address != nil {
		existingWallet.Address = *input.Address
	}

	_, err = collection.UpdateOne(
		ctx,
		bson.M{"walletID": walletID},
		bson.M{"$set": bson.M{"address": existingWallet.Address}},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to update wallet %v", err)
	}

	return &existingWallet, nil
}

// ReferralCount is the resolver for the referralCount field.
func (r *mutationResolver) ReferralCount(ctx context.Context, link string) (*model.Referral, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERRAL"))

	var referal model.Referral

	filter := bson.M{"link": link}

	err := collection.FindOne(ctx, filter).Decode(&referal)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no references found")
	} else if err != nil {
		return nil, fmt.Errorf("error finding references: %v", err)
	}

	referal.Count += 1

	update := bson.M{
		"$set": bson.M{"count": referal.Count},
	}
	_, err = collection.UpdateOne(ctx, filter, update)

	if err != nil {
		return nil, fmt.Errorf("failed to increament count")
	}

	return &referal, nil
}

// VerifyUser is the resolver for the VerifyUser field.
func (r *mutationResolver) VerifyUser(ctx context.Context, uniqueverifier string) (*bool, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION"))

	var verification model.Verify
	filter := bson.M{"uniqueverifier": uniqueverifier}
	err := collection.FindOne(ctx, filter).Decode(&verification)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no verification found")
	} else if err != nil {
		return nil, fmt.Errorf("error finding verification: %v", err)
	}

	verification.Verified = true

	update := bson.M{
		"$set": bson.M{"verified": verification.Verified},
	}
	_, err = collection.UpdateOne(ctx, filter, update)

	if err != nil {
		return nil, fmt.Errorf("failed to verify user")
	}

	return &verification.Verified, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *notificationResolver) Timestamp(ctx context.Context, obj *model.Notification) (*string, error) {
	if obj == nil || obj.Timestamp.IsZero() {
		return nil, nil
	}

	timestampStr := obj.Timestamp.Format(time.RFC3339)
	return &timestampStr, nil
}

// GetAllUsers is the resolver for the getAllUsers field.
func (r *queryResolver) GetAllUsers(ctx context.Context) ([]*model.User, error) {
	// Fetch all users from the database
	users, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching users: %v", err)
	}
	defer users.Close(ctx)

	// Iterate through the cursor and populate the results
	var result []*model.User
	for users.Next(ctx) {
		var user *model.User
		if err := users.Decode(&user); err != nil {
			return nil, fmt.Errorf("error decoding user: %v", err)
		}
		result = append(result, user)
	}

	if err := users.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*model.User, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("COLLECTION_NAME"))

	var user model.User
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no user found with userID: %s", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding user: %v", err)
	}

	return &user, nil
}

// GetAllBalances is the resolver for the getAllBalances field.
func (r *queryResolver) GetAllBalances(ctx context.Context) ([]*model.Balance, error) {
	balances, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("BALANCES")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching balances: %v", err)
	}
	defer balances.Close(ctx)

	var result []*model.Balance
	for balances.Next(ctx) {
		var balance *model.Balance
		if err := balances.Decode(&balance); err != nil {
			return nil, fmt.Errorf("error decoding balance: %v", err)
		}
		result = append(result, balance)
	}

	if err := balances.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetBalance is the resolver for the getBalance field.
func (r *queryResolver) GetBalance(ctx context.Context, userID string) (*model.Balance, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("BALANCES"))

	var balance model.Balance
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&balance)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no history found for user %v", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding balance: %v", err)
	}

	return &balance, nil
}

// GetAllInvestments is the resolver for the getAllInvestments field.
func (r *queryResolver) GetAllInvestments(ctx context.Context) ([]*model.Investment, error) {
	investments, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("INVESTMENTS")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching investments: %v", err)
	}
	defer investments.Close(ctx)

	var result []*model.Investment
	for investments.Next(ctx) {
		var investment *model.Investment
		if err := investments.Decode(&investment); err != nil {
			return nil, fmt.Errorf("error decoding investment: %v", err)
		}
		result = append(result, investment)
	}

	if err := investments.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetInvestment is the resolver for the getInvestment field.
func (r *queryResolver) GetInvestment(ctx context.Context, userID string) (*model.Investment, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("INVESTMENTS"))

	var investment model.Investment
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&investment)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no investment found for user %v", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding investment: %v", err)
	}

	return &investment, nil
}

// GetAllCredits is the resolver for the getAllCredits field.
func (r *queryResolver) GetAllCredits(ctx context.Context) ([]*model.Credit, error) {
	credits, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("CREDITS")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching credits: %v", err)
	}
	defer credits.Close(ctx)

	var result []*model.Credit
	for credits.Next(ctx) {
		var credit *model.Credit
		if err := credits.Decode(&credits); err != nil {
			return nil, fmt.Errorf("error decoding credit: %v", err)
		}
		result = append(result, credit)
	}

	if err := credits.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetCredit is the resolver for the getCredit field.
func (r *queryResolver) GetCredit(ctx context.Context, userID string) (*model.Credit, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("CREDITS"))

	var credit model.Credit
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&credit)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no credit found for user %v", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding credit: %v", err)
	}

	return &credit, nil
}

// GetAllReferences is the resolver for the getAllReferences field.
func (r *queryResolver) GetAllReferences(ctx context.Context) ([]*model.Reference, error) {
	references, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERERS")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching references: %v", err)
	}
	defer references.Close(ctx)

	var result []*model.Reference
	for references.Next(ctx) {
		var reference *model.Reference
		if err := references.Decode(&reference); err != nil {
			return nil, fmt.Errorf("error decoding reference: %v", err)
		}
		result = append(result, reference)
	}
	if err := references.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}
	return result, nil
}

// GetReference is the resolver for the getReference field.
func (r *queryResolver) GetReference(ctx context.Context, userID string) (*model.Reference, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERERS"))

	var reference model.Reference
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&reference)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no reference found for user %v", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding reference: %v", err)
	}

	return &reference, nil
}

// GetReferral is the resolver for the getReferral field.
func (r *queryResolver) GetAllReferral(ctx context.Context) ([]*model.Referral, error) {
	ref, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERRAL")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching all referrals: %v", err)
	}
	defer ref.Close(ctx)

	var result []*model.Referral
	for ref.Next(ctx) {
		var refer *model.Referral
		if err := ref.Decode(&refer); err != nil {
			return nil, fmt.Errorf("error decoding referral: %v", err)
		}
		result = append(result, refer)
	}

	if err := ref.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetReferral is the resolver for the getReferral field.
func (r *queryResolver) GetReferral(ctx context.Context, userID *string) (*model.Referral, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("REFERRAL"))

	var referral model.Referral
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&referral)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no referral found for user %v", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding referral: %v", err)
	}

	return &referral, nil
}

// GetAllMemos is the resolver for the getAllMemos field.
func (r *queryResolver) GetAllMemos(ctx context.Context) ([]*model.Memo, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("MEMO"))

	cursor, err := collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching memo: %v", err)
	}
	defer cursor.Close(ctx)

	var memo []*model.Memo
	if err = cursor.All(ctx, bson.M{}); err != nil {
		return nil, fmt.Errorf("error decoding memo: %v", err)
	}

	return memo, nil
}

// GetMemo is the resolver for the getMemo field.
func (r *queryResolver) GetMemo(ctx context.Context, userID string) (*model.Memo, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("MEMO"))

	var memo model.Memo
	filter := bson.M{"userid": userID}

	err := collection.FindOne(ctx, filter).Decode(&memo)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no memo found for user %v", userID)
	} else if err != nil {
		return nil, fmt.Errorf("error finding memo with user: %v", err)
	}

	return &memo, nil
}

// GetAllAssets is the resolver for the getAllAssets field.
func (r *queryResolver) GetAllAssets(ctx context.Context) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: GetAllAssets - getAllAssets"))
}

// GetAsset is the resolver for the getAsset field.
func (r *queryResolver) GetAsset(ctx context.Context, assetID string) (*model.Asset, error) {
	panic(fmt.Errorf("not implemented: GetAsset - getAsset"))
}

// GetUserAssets is the resolver for the getUserAssets field.
func (r *queryResolver) GetUserAssets(ctx context.Context, userID string) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: GetUserAssets - getUserAssets"))
}

// GetAllHistory is the resolver for the getAllHistory field.
func (r *queryResolver) GetAllHistory(ctx context.Context) ([]*model.History, error) {
	histories, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching history: %v", err)
	}
	defer histories.Close(ctx)

	var result []*model.History
	for histories.Next(ctx) {
		var history *model.History
		if err := histories.Decode(&history); err != nil {
			return nil, fmt.Errorf("error decoding history: %v", err)
		}
		result = append(result, history)
	}

	return result, nil
}

// GetHistory is the resolver for the getHistory field.
func (r *queryResolver) GetHistory(ctx context.Context, id string) (*model.History, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))

	var history model.History
	filter := bson.M{"id": id}

	err := collection.FindOne(ctx, filter).Decode(&history)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("no history found with id: %s", id)
	} else if err != nil {
		return nil, fmt.Errorf("error finding history: %v", err)
	}

	return &history, nil
}

// GetUserHistory is the resolver for the getUserHistory field.
func (r *queryResolver) GetUserHistory(ctx context.Context, userID string) ([]*model.History, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))

	filter := bson.M{"userid": userID}

	// Query MongoDB for history records matching the filter
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching history: %v", err)
	}
	defer cursor.Close(ctx)

	// Initialize slice to store fetched history records
	var histories []*model.History

	// Iterate through the cursor and decode each document into a History struct
	for cursor.Next(ctx) {
		var history model.History
		if err := cursor.Decode(&history); err != nil {
			return nil, fmt.Errorf("error decoding history: %v", err)
		}
		histories = append(histories, &history)
	}

	// Check for any cursor errors after iteration
	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return histories, nil
}

// GetAllTransactions is the resolver for the getAllTransactions field.
func (r *queryResolver) GetAllTransactions(ctx context.Context) ([]*model.Transaction, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("TRANSACT"))

	cursor, err := collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching transactions: %v", err)
	}
	defer cursor.Close(ctx)

	var transactions []*model.Transaction
	for cursor.Next(ctx) {
		var transaction model.Transaction
		if err := cursor.Decode(&transaction); err != nil {
			return nil, fmt.Errorf("error decoding transaction: %v", err)
		}
		transactions = append(transactions, &transaction)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return transactions, nil
}

// GetTransaction is the resolver for the getTransaction field.
func (r *queryResolver) GetTransaction(ctx context.Context, id string) (*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: GetTransaction - getTransaction"))
}

// GetAllUserTransaction is the resolver for the getAllUserTransaction field.
func (r *queryResolver) GetAllUserTransaction(ctx context.Context, id string) ([]*model.Transaction, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("TRANSACT"))

	filter := bson.M{"id": id}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching transactions: %v", err)
	}
	defer cursor.Close(ctx)

	var transactions []*model.Transaction

	for cursor.Next(ctx) {
		var transaction model.Transaction
		if err := cursor.Decode(&transaction); err != nil {
			return nil, fmt.Errorf("error decoding transaction: %v", err)
		}
		transactions = append(transactions, &transaction)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return transactions, nil
}

// GetUserCreditTransactions is the resolver for the getUserCreditTransactions field.
func (r *queryResolver) GetUserCreditTransactions(ctx context.Context, to string) ([]*model.Transaction, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("TRANSACT"))

	filter := bson.M{"to": to}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching transactions: %v", err)
	}
	defer cursor.Close(ctx)

	var transactions []*model.Transaction

	for cursor.Next(ctx) {
		var transaction model.Transaction
		if err := cursor.Decode(&transaction); err != nil {
			return nil, fmt.Errorf("error decoding transaction: %v", err)
		}
		transactions = append(transactions, &transaction)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return transactions, nil
}

// GetUserDebutTransactions is the resolver for the getUserDebutTransactions field.
func (r *queryResolver) GetUserDebutTransactions(ctx context.Context, from string) ([]*model.Transaction, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("TRANSACT"))

	filter := bson.M{"from": from}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching transactions: %v", err)
	}
	defer cursor.Close(ctx)

	var transactions []*model.Transaction

	for cursor.Next(ctx) {
		var transaction model.Transaction
		if err := cursor.Decode(&transaction); err != nil {
			return nil, fmt.Errorf("error decoding transaction: %v", err)
		}
		transactions = append(transactions, &transaction)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return transactions, nil
}

// GetAllNotification is the resolver for the getAllNotification field.
func (r *queryResolver) GetAllNotification(ctx context.Context) ([]*model.Notification, error) {
	notifications, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching notifications: %v", err)
	}
	defer notifications.Close(ctx)

	var result []*model.Notification
	for notifications.Next(ctx) {
		var notification *model.Notification
		if err := notifications.Decode(&notification); err != nil {
			return nil, fmt.Errorf("error decoding notification: %v", err)
		}
		result = append(result, notification)
	}

	if err := notifications.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetUserNotifications is the resolver for the getUserNotifications field.
func (r *queryResolver) GetUserNotifications(ctx context.Context, userID string) ([]*model.Notification, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("NOTIFICATION_LOG"))

	filter := bson.M{"userid": userID}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("error fetching notifications: %v", err)
	}
	defer cursor.Close(ctx)

	var notifications []*model.Notification
	for cursor.Next(ctx) {
		var notification model.Notification
		if err := cursor.Decode(&notification); err != nil {
			return nil, fmt.Errorf("error decoding notification: %v", err)
		}
		notifications = append(notifications, &notification)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return notifications, nil
}

// GetAllUnverifiedEmails is the resolver for the getAllUnverifiedEmails field.
func (r *queryResolver) GetAllUnverifiedEmails(ctx context.Context) ([]*model.Verify, error) {
	allUnverified, err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION")).Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching unverified emails: %v", err)
	}
	defer allUnverified.Close(ctx)

	var result []*model.Verify
	for allUnverified.Next(ctx) {
		var unverified *model.Verify
		if err := allUnverified.Decode(&unverified); err != nil {
			return nil, fmt.Errorf("error decoding unverified email: %v", err)
		}
		result = append(result, unverified)
	}
	if err := allUnverified.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return result, nil
}

// GetUnverifiedEmail is the resolver for the getUnverifiedEmail field.
func (r *queryResolver) GetUnverifiedEmail(ctx context.Context, email string) (*model.Verify, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION"))

	var user model.Verify
	filter := bson.M{"email": email}
	err := collection.FindOne(ctx, filter).Decode(&user)
	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("%v not found. could be that the email address is already verified or does not exist", email)
	} else if err != nil {
		return nil, fmt.Errorf("error finding email: %v", err)
	}

	return &user, nil
}

// GetAllPlans is the resolver for the getAllPlans field.
func (r *queryResolver) GetAllPlans(ctx context.Context) ([]*model.Plan, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("PLANS"))

	// Fetch all plans
	cursor, err := collection.Find(ctx, bson.M{})
	if err != nil {
		return nil, fmt.Errorf("error fetching plans: %v", err)
	}
	defer cursor.Close(ctx)

	var plans []*model.Plan
	if err = cursor.All(ctx, &plans); err != nil {
		return nil, fmt.Errorf("error decoding plans: %v", err)
	}

	return plans, nil
}

// GetPlan is the resolver for the getPlan field.
func (r *queryResolver) GetPlan(ctx context.Context, planID string) (*model.Plan, error) {
	panic(fmt.Errorf("not implemented: GetPlan - getPlan"))
}

// GetWallet is the resolver for the getWallet field.
func (r *queryResolver) GetWallet(ctx context.Context) (*model.Wallet, error) {
	var wallet model.Wallet
	err := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("WALLET")).FindOne(ctx, bson.M{}).Decode(&wallet)
	if err != nil {
		return nil, fmt.Errorf("error fetching wallet: %v", err)
	}

	return &wallet, nil
}

// GetUserVerificationToken is the resolver for the getUserVerificationToken field.
func (r *queryResolver) GetUserVerificationToken(ctx context.Context, email string) (*model.Verify, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("VERIFICATION"))

	var verify *model.Verify
	filter := bson.M{"email": email}
	err := collection.FindOne(ctx, filter).Decode(&verify)

	if err == mongo.ErrNoDocuments {
		return nil, fmt.Errorf("%v not found. could be that the email address is already verified or does not exist", email)
	} else if err != nil {
		return nil, fmt.Errorf("error finding email: %v", err)
	}

	return verify, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *referenceResolver) Timestamp(ctx context.Context, obj *model.Reference) (*string, error) {
	panic(fmt.Errorf("not implemented: Timestamp - timestamp"))
}

// ID is the resolver for the id field.
func (r *transactionResolver) ID(ctx context.Context, obj *model.Transaction) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *model.User) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Balance is the resolver for the balance field.
func (r *userResolver) Balance(ctx context.Context, obj *model.User) ([]*model.Balance, error) {
	panic(fmt.Errorf("not implemented: Balance - balance"))
}

// Investment is the resolver for the investment field.
func (r *userResolver) Investment(ctx context.Context, obj *model.User) ([]*model.Investment, error) {
	panic(fmt.Errorf("not implemented: Investment - investment"))
}

// Credits is the resolver for the credits field.
func (r *userResolver) Credits(ctx context.Context, obj *model.User) ([]*model.Credit, error) {
	panic(fmt.Errorf("not implemented: Credits - credits"))
}

// Reference is the resolver for the reference field.
func (r *userResolver) Reference(ctx context.Context, obj *model.User) ([]*model.Reference, error) {
	panic(fmt.Errorf("not implemented: Reference - reference"))
}

// Assets is the resolver for the assets field.
func (r *userResolver) Assets(ctx context.Context, obj *model.User) ([]*model.Asset, error) {
	panic(fmt.Errorf("not implemented: Assets - assets"))
}

// History is the resolver for the history field.
func (r *userResolver) History(ctx context.Context, obj *model.User) ([]*model.History, error) {
	collection := r.MongoClient.Database(os.Getenv("DB_NAME")).Collection(os.Getenv("HISTORY_LOG"))

	cursor, err := collection.Find(ctx, bson.M{"user_id": obj.UserID})
	if err != nil {
		return nil, fmt.Errorf("error fetching history: %v", err)
	}
	defer cursor.Close(ctx)

	var histories []*model.History
	for cursor.Next(ctx) {
		var history model.History
		if err := cursor.Decode(&history); err != nil {
			return nil, fmt.Errorf("error decoding history: %v", err)
		}
		histories = append(histories, &history)
	}

	if err := cursor.Err(); err != nil {
		return nil, fmt.Errorf("cursor error: %v", err)
	}

	return histories, nil
}

// Transactions is the resolver for the transactions field.
func (r *userResolver) Transactions(ctx context.Context, obj *model.User) ([]*model.Transaction, error) {
	panic(fmt.Errorf("not implemented: Transactions - transactions"))
}

// Notification is the resolver for the Notification field.
func (r *userResolver) Notification(ctx context.Context, obj *model.User) ([]*model.Notification, error) {
	panic(fmt.Errorf("not implemented: Notification - Notification"))
}

// ID is the resolver for the id field.
func (r *verifyResolver) ID(ctx context.Context, obj *model.Verify) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Balance returns BalanceResolver implementation.
func (r *Resolver) Balance() BalanceResolver { return &balanceResolver{r} }

// Credit returns CreditResolver implementation.
func (r *Resolver) Credit() CreditResolver { return &creditResolver{r} }

// History returns HistoryResolver implementation.
func (r *Resolver) History() HistoryResolver { return &historyResolver{r} }

// Investment returns InvestmentResolver implementation.
func (r *Resolver) Investment() InvestmentResolver { return &investmentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Notification returns NotificationResolver implementation.
func (r *Resolver) Notification() NotificationResolver { return &notificationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Reference returns ReferenceResolver implementation.
func (r *Resolver) Reference() ReferenceResolver { return &referenceResolver{r} }

// Transaction returns TransactionResolver implementation.
func (r *Resolver) Transaction() TransactionResolver { return &transactionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// Verify returns VerifyResolver implementation.
func (r *Resolver) Verify() VerifyResolver { return &verifyResolver{r} }

type balanceResolver struct{ *Resolver }
type creditResolver struct{ *Resolver }
type historyResolver struct{ *Resolver }
type investmentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type referenceResolver struct{ *Resolver }
type transactionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type verifyResolver struct{ *Resolver }